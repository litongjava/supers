# supers
1.编写为两个命令 superd(服务端),supers(客户端)
2.superd 启动后,端口是10405,启动/etc/super/下面配置的所有程序,例如docker-io-proxy.service
3.可以通过supers对这些程序进行管理 启动,关闭,查看状态,显示所有程序状态,日志目录是/etc/super/logs/ 一个程序一个目录,程序名测试配置文件的名称,没有service
4.superd 守护程序目前配置文件部分我已经完成
6.supers和superd采用unix sock进行通讯
```shell
[Unit]
Description=docker-io-proxy Java Web Service
After=network.target

[Service]
Type=simple
User=root
WorkingDirectory=/data/apps/docker-io-proxy
ExecStart=/usr/java/jdk1.8.0_211/bin/java -jar target/docker-io-proxy-1.0.0.jar --server.port=8004
Restart=on-failure
RestartSec=5s

[Install]
WantedBy=default.target
```
## 一、需求分析

1. **功能对标**
    * 进程管理（启动/停止/重启/状态查询）
    * 自动重启（异常退出后重启、进程退出码策略）
    * 日志收集与切割
    * 配置管理（支持 INI／YAML）
    * 事件通知（邮件／Webhook）
    * Web 控制界面和 CLI
2. **非功能需求**

    * 高可用：支持配置 reload、平滑重载
    * 轻量级：进程间内存占用低，依赖尽量少
    * 扩展性：插件式事件与通知
    * 跨平台：Linux、macOS，未来可考虑 Windows

---

## 二、系统设计

### 1. 总体架构

```text
+--------------------+      +----------------------+      +------------------+
|   CLI & Unix sock  | <--> |    控制中心（Daemon）   | <--> |   子进程管理器     |
+--------------------+      +----------------------+      +------------------+
                                       |
                                       +--> Event Dispatcher
                                       |
                                       +--> Config Loader
                                       |
                                       +--> Logger Manager
```

### 2. 核心组件

* **Daemon（守护进程）**
    * 单例，负责加载配置、管理子进程生命周期
* **Process Manager**

    * 基于 `os/exec` 启动、监控进程，监听退出信号并重启
* **Config Loader**

    * 支持 INI（github.com/go-ini/ini）或 YAML（gopkg.in/yaml.v3）
* **Event Dispatcher**

    * 进程状态变更、日志异常时发送事件，可挂载多种通知插件
* **Logger Manager**

    * 将子进程 stdout/stderr 转写到文件，并支持 LRU 切割（按大小/时间）
* **HTTP API & CLI**

    * Gin 或 Echo 实现 RESTful API；配套简单 CLI（cobra/viper）

---

## 三、模块拆分与技术选型

| 模块        | 主要职责                         | 技术/库选型                       |
| --------- | ---------------------------- | ---------------------------- |
| 配置解析      | 加载、校验  | g        |
| 进程管理      | 启动、停止、重启、状态检测，退出码策略          | `os/exec` + channel + context |
| 日志管理      | stdout/stderr 收集，文件轮转        | 标准 `io` + 自研轮转 或 lumberjack  |
| 事件分发      | 进程异常、重启、挂掉等事件的统一分发与通知        | 自研事件总线 + 插件接口                |
| HTTP 控制接口 | 提供 JSON API：增删改查服务、查看日志、事件订阅 |          |
| CLI       | 本地命令行管理：`supers`   | cobra + viper                |
| 权限与安全     | API 访问控制、Token 验证            | JWT 或简单 Token 机制             |
| 打包与发布     | 单二进制部署                       | Go Modules + goreleaser      |

---

## 四、迭代开发与测试

| 阶段       | 目标                               | 验收标准                           |
|----------| -------------------------------- | ------------------------------ |
| Sprint 1 | Daemon 启动骨架；  | 成功加载配置并用命令行启动一个 `sleep` 进程     |
| Sprint 2 | 进程监控与自动重启；退出码策略                  | 强制 `sleep` 进程退出，Daemon 能按策略重启  |
| Sprint 3 | 日志收集与切割；本地 CLI 控制                | 子进程日志写入文件，CLI 可查看日志与服务状态       |
| Sprint 4 | 事件分发框架；Webhook 通知插件              | 配置 Webhook 后，子进程异常时能发送 HTTP 回调 |

| 阶段       | 目标                                   | 验收标准                                                                                                                                                                                                  |
| -------- | ------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Sprint 5 | 配置加载所有 `/etc/super/*.service` 并动态管理。 | 1. 增加 `reload` 命令：通过 `supers reload`（或向 superd 发送 `reload`）可以动态重新加载 `/etc/super/*.service` 下的所有配置，新增的 service 自动启动，删除的 service 自动停止。<br>2. 支持新增配置文件后，无需手动 reload，即可执行 `supers start <name>` 启动新加入的服务。 |
---